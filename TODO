- Value Class Support
- Opaque Type Aliases
- Dependent type support (match types)
- Java Class Support
- Scala plain-class support
- Option (java/scala)
- Structural Types
- Either
- Scala Collections Support
- Java Collections Support
- Tuple support
- Any type support
- Java Object type (like Any)
- Extensible Info support (e.g. UUID, datetime)
- Nested Java classes (field of Java class is another Java class)
- UnknownClass ConcreteType implementation
- User-written Java parameterized type
- Field in class is an object (i.e. reflect on an object)

Extractors Needed:
- Try support
- Enumeration (various flavors?)
- Sealed Trait

- Runtime object blending
* Discern initial/requested value of [T], e.g. write[Person](obj)... T = Person

NOTE: Scala plain classes *not* using val constructor args are no longer supported!


Build Dotty:

sbt dotty-bootstrapped/publishLocal

Testing Dotty:

All JDK >= 8 should work
Our CI only tests 8 and 11
I don't know what's going on in your build, try doing a clean from sbt
test will not run bootstrapped-only tests like tasty-inspector, you need dotty-bootstrapped/test
You can run a single test like this: dotty-bootstrapped/testCompilation tasty-inspector


Results:
JDK13: ~17 build failures with 1000s of warning messages
JDK11: 3 build failures
JDK8:  2 failures

Hello!  Working on the "last mile" for runtime reflection, which is the intial type parameter detection.  So for example:
```scala
read[Thing[Int]](js:String)
```
I need to detect that Thing has a parameter of Int.  Java (un)helpfully erases this for me.  Inside Tasty reflection we're all good--this information is available in the Tasty file and can be sewn down to where it is needed.  
But top-level when I call this function it's not available--it's before we've started reading Tasty files.

Would a macro work here, i.e. read() is macro?  Here's the nuance...  def read[T](js: String) internally needs to call Reflector.reflectOn[T] THEN call the parsing code with the reflected information.  Can macros "chain" to a non-macro like that?
The logical flow:
```scala
def read[T](js: String) {
  val inspected = Reflector.reflectOn[T]
  jsonParser.readInto(js, inspected).asInstanceOf[T]
}
// Can read() be a macro but have it's internals execute at runtime?
```


